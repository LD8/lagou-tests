# 说一下 V8 的垃圾回收机制（小米）

V8 是一款主流的 JS 执行引擎，采用即时编译，网页应用限制内存 800MB（32 位系统）/1.5GB（64 位系统）。以 64 位系统为例，V8 引擎的垃圾回收机制在应用占用 1.5G 内存时，采用增量标记算法开始回收垃圾。

V8 垃圾回收策略采用「分代回收」算法：内存一分为二（新生代和老生代），针对不同对象采用不同算法

## V8 新生代回收

- 新生代对象：生命周期相对较短的对象
- 新生代空间：64 位系统 32M，32 位系统 16M
- 新生代空间分割：分为 2 个大小相等的空间（from 和 to）
- 回收过程：标记清除、标记整理、置换
  - from：存放活动对象，所有的对象声明都会在这里
  - 触发 GC 机制后：
  - 在 from 空间中进行标记，找到活动对象
  - 在 from 空间中进行整理，防止内存地址碎片化
  - 从 from 空间中拷贝整理过后的活动对象至 to 空间中，此时可能发生晋升操作，即：将新生代对象移动至老生代，晋升标准：
    - 1 整轮 GC 回收过后还存货的新生代对象
    - to 空间使用率超过 25%，所有的 to 空间中的对象都会被复制进老生代空间
  - 释放 from 空间
  - 2 个空间进行交换，from 变成了 to，to 变成了 from，完成回收

## V8 老生代回收

- 老生代对象：生命周期相对较长的对象（如：闭包的对象等）
- 老生代空间：64 位系统 1.4GB，32 位操作系统 700MB
- 回收过程：
  - 标记清除算法：主要采用这种算法
  - 标记整理算法：当从新生代晋升的数据过大，老生代空间不足时使用
  - 增量标记算法：效率优化

## 标记增量

- 增量标记算法的使用场景：在老年代中使用标记增量算法做 GC，因为老年代中存放的数据较多（老年代存储区最多有 1.4G），采用类似新生代中的复制算法耗时较长，可能造成卡顿程序暂停的情况
- 增量标记算法工作原理
  1.  触发 GC 机制
  2.  此时程序继续执行
  3.  遍历一层可达对象，并做标记
  4.  程序继续执行
  5.  标记二层可达对象，并做标记
  6.  程序继续执行
  7.  标记完成
  8.  程序继续执行
  9.  整理内存、释放内存、完成回收
